## 1. 递归
编写递归时，必须告诉它何时停止递归。
每个递归函数分为两部分:
1. 基线条件: 函数不再调用自己。
1. 递归条件：函数调用自己。

## 2.调用栈 （call stack）
> 盒子问题： 在一个盒子里找钥匙，盒子里有盒子，钥匙装在其中的一个小盒子里。

> **==栈==**: 一个待办事项清单:一叠便条。
> 插入的待办事项放在清单的最前面；读取待办事项时，只读取最上边那个，并将其删除。
#### ==压入(插入)和弹出(删除并读取)==
计算机内部使用被称为==调用栈==的栈

**++调用一个函数时，当前函数暂停并处于未完成状态，该函数的所有变量的值都还在内存中。++**

栈：用于存储多个函数的==变量==，被称为调用栈。
计算机使用一个栈来表示函数、变量占用的内存块。

**==递归调用栈==**

使用栈很方便——无需自己跟踪“盒子堆“，栈替你做了。
但要付出==代价：存储详细信息可能占大量内存==。每个函数的调用都要占一定的内存，如果栈很高，就意味着计算机存储了大量函数调用的信息。这种情况下，有两种选择——

- 重新编码，转而==使用循环==，跟踪“盒子堆”
- 使用==尾递归==。

## 3.快速排序法  
**分而治之** D&C
平均运行时间: O(n logn) 


## 4.数据结构:散列表 (hash table)
**组成: ==散列函数== + ==数组==**
> 包含额外逻辑的数据结构

数组个数链都直接映射到内存中，散列表更复杂，使用散列函数来确定元素的存储位置。

**==散列表由键和值组成==**。

**散列表防止重复**：

```
voted = {};
value = voted.get("tom");
```
与列表相比，在散列表中该函数速度非常快。

**缓存**是一种常用的加速方式，所有大型网站都使用缓存，而缓存的数据则存储在散列表中。缓存页面，需要将页面的URL映射到页面数据。

**冲突**: 给两个键分配的位置相同，若有冲突，值将被覆盖。
冲突的解决：最简单的方法，若两个键映射到了一个位置，就在该位置存储一个链表。

**要避免冲突，需要有**：
- 较低的填装因子。
- 良好的散列函数。
填装因子越低，发生冲突的可能性就越小，散列表的性能就越高。一个不错的经验规则是，一旦填装因子大于0.7，就调整散列表的长度。

++**良好的散列函数**：可参考==SHA==函数++。

**SHA（secure hash algorithm）安全散列算法**。

SHA函数，生成一个==散列值==——一个较短的字符串。
==对于每个不同的字符串，SHA生成的散列值都不一样==。

- SHA可用于比较两个文件是否相同。
- SHA被广泛用于计算密码的散列值，这种散列算法是单向的。
SHA实际上是一系列算法:SHA-0,SHA-1,SHA-2和SHA-3。SHA-0,SHA-1有缺项，使用SHA-2和SHA-3。
更安全散列函数：bcrypt。


有时候我们希望散列函数是**局部敏感**的，计算出相似程度，可用于比较论文是否抄袭、网页是否已搜索。
局部敏感的散列函数：Simhash

## 5.图算法-广度优先搜索
==**广度优先搜索**==：解决最短路径的算法

最短路径问题：
1. 使用图建立问题模型。
1. 使用广度优先搜索解决问题。
2. 
图模拟一组连接，由节点和边组成。

**广度优先搜索**是一种用于图的查找算法，可帮助解决两类问题。
第一类：从节点A出发，有前往节点B的路径么?
第二类：从节点A出发，前往节点B的哪条路径最短?





